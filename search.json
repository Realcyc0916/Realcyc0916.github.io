[{"title":"CSP2021游记","url":"/2025/02/06/CSP2021/","content":"2024.2 重新编辑了下， 顺便附上赛时代码(当时的我真的菜啊~)\n\n## 初赛\n\n#### day -20\n\n暑假集训回来了，疯狂补whk作业\n\n#### day -16\n\n开学，上课复习OI\n\n#### day -14 ~ day -10\n\n高强度学初赛，做了3次模拟，分数分别为 38 59 77\n\n#### day -6\n\n模拟可以稳到70+，很大的进步\n\n#### day -2\n\n好家伙，校队老师说拿奖给我整个颁奖典礼(目前来看好像咕了)\n\n#### day -1\n\n颓了一天，喝点咖啡就睡了（不是哥们为什么睡觉要喝咖啡啊!\n\n#### day 0\n\n去考场见到了许久未见的xyh巨佬，xyh和他的lq同学吊打我，并议论karry5307\n\n开考了 S组难得一批，acos(-0.5)是啥我也不晓得，立体几何我也没学过，还考了四毛子，根本不会，手算base64，草，连猜带蒙结束了。\n\n中午去吃了个牛排。。。接着对了下答案，S50左右，危\n\n下午是J组 难度还行，居然考了个约瑟夫？不要太简单\n\n出来之后对答案居然也只有50左右? 最有信心的约瑟夫竟然全错，明年再见了...\n\n#### day 8\n\n出分了，J66，S55.5，J竟然卡线进，离谱.\n\n## 复赛\n\n#### day -15\n\n大家好，窝又回来了！还有十几天就CSP复赛，但我连搜索都学不怎么会\n\n#### day -14 ~ day -8\n\n哈哈 我真菜，快要放弃了/kk\n\n#### day -2\n\n水了几天红题，信心大增\n\n#### day -1\n\n早上~~直接罢课~~做了几题历年题，打印了些准考证啥的。。。\n\n下午，经过15min的共享单车和30min的地铁后，终于坐上了G****(~~属实是忘了~~)还是复兴号，因为2=座没了直接买了1=座，哈哈人生头一次1=座，希望这次也能拿个1=回家!\n\n##### 1 hour later\n\n到了！杭州东！大城市就是不一样啊哈哈哈，不过这地铁网络购票为啥这么麻烦啊(~~比宁波麻烦多了~~)\n\n再地铁上拿着小小的iPhone 5s问xyh巨佬住哪儿，~~惊了，居然住我楼下~~。\n\n地铁上还碰到了一个很像老番茄的人\n\n2130的地铁，人群还是熙熙攘攘，对比宁波地铁，这个时间点或许早已空无一人了吧 听着亲切却又陌生的杭州话，到站了，浙大紫金港\n\n到了酒店已经2230，洗洗随便打了几个板子就直接睡了\n\n### day 0\n\n起床，0630\n\n在酒店吃了早饭，感觉不是很牛\n\n洛谷打卡后随便走了走，吃了个早饭就上考场了，不得不说学军真大...\n\n面到了几个lq巨佬，没有见到xyh\n\n学军就是不一样啊！电脑配这么好的。。。我们学校的开个浏览器都要半天，别说Dev了\n\n打了快读和__int128板子，开考了，解压密码一遍过，好兆头。\n\n拿到T1以为是dp，想了一下无果，开T2，看题面感觉是什么很复杂的数据结构，写了个$O(n^3)$的暴力跑路\n\n回去看T1，1e9的数据，这写$O(n)$过不了吧，看了会发现是道数论，想了很久没推出公式，写了$O(n)$暴力，希望能得80\n\n还有1:05，去看T3，原来是道大模拟，写了一半感觉有些东西不知道怎么写，但是好像拿点部分分还是没啥问题的，没什么时间了，检查了下文件名。\n\n看了眼T4，发现是神笔题，感觉暴力甚至可以70，不过完全没有时间了我是傻逼啊啊啊。\n\n期望得分 80+30+50+0=160\n\n二等应该有了\n\n出考场面到了xyh，据说他T2写的$O(N^2)$，但好像也挂了挺多地方的，祝好\n\n中午去吃了必胜客，还行，随便逛了下Apple的店，动车回家了\n\n### day 1\n\n补作业，太多了根本写不完，大不了明天和老师爆了。\n\n### day x?\n\n用luogu跑了下我代码居然 100+52+35+0=187\n信心倍增，但是还是无望1=\n\n### day 12\n\n出分了，90+52+35+0=177，喜提了个二等+4级勾回家\nT1挂了10分，复杂度是错的，也在情理之中了，~这luogu的数据也太水了~\n\n### 完。\n\n## 附赛时代码\n\n\n### T1\n\n```cpp\n#include<iostream>\n#include<cmath>\nusing namespace std;\nlong long n,l,r,maxx=-1000001,ans;\nlong long find(long long x)\n{\n    return x%n;\n}\nint main()\n{\n    freopen(\"candy.in\",\"r\",stdin);\n    freopen(\"candy.out\",\"w\",stdout);\n    cin>>n>>l>>r;\n    if(n==1)\n    {\n        cout<<r<<endl;\n        return 0;\n    }\n    for(long long i=l;i<=r;i++)\n    {\n        maxx=max(maxx,find(i));\n    }\n    cout<<maxx<<endl;\n    return 0;\n}\n```\n\n### T2\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nint n,q,a[8005],b[8005],t1,t2,t3,num,l,r;\nint main()\n{\n    freopen(\"sort.in\",\"r\",stdin);\n    freopen(\"sort.out\",\"w\",stdout);\n    cin>>n>>q;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        b[i]=a[i];\n    }\n    for(int i=1;i<=q;i++)\n    {\n        scanf(\"%d\",&num);\n        if(num==1)\n        {\n            scanf(\"%d\",&t1);\n            scanf(\"%d\",&t2);\n            a[t1]=t2;\n            b[t1]=t2;\n        }\n        else if(num==2)\n        {\n            scanf(\"%d\",&t3);\n            for(int j=1;j<=n;j++)\n            {\n                for(int k=j;k>=2;k--)\n                {\n                    if(b[k]<b[k-1])\n                    {\n                        if(k==t3)\n                        {\n                            --t3;\n                            //cout<<t3<<endl;\n                        }\n                        else if((k-1)==t3)\n                        {\n                            ++t3;\n                            //cout<<t3<<endl;\n                        }\n                        swap(b[k],b[k-1]);\n                    }\n                }\n            }\n            cout<<t3<<endl;\n            for(int x=1;x<=n;x++)\n            {\n                b[x]=a[x];\n            }\n        }\n    }\n    return 0;\n}\n```\n\n### T3\n```cpp\n#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long n,a[1005],b[1005],c[1005],d[1005],e[1005],i;\nstring s1[1005];\nbool flag=false,flag1[1005];\nbool check(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j)\n{\n    if(a==b&&c==d&&e==f&&g==h&&i==j)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\nint main()\n{\n    freopen(\"network.in\",\"r\",stdin);\n    freopen(\"network.out\",\"w\",stdout);\n    cin>>n;\n    for(i=1;i<=n;i++)\n    {\n        cin>>s1[i];\n        scanf(\"%d.%d.%d.%d:%d\",&a[i],&b[i],&c[i],&d[i],&e[i]);\n    }\n    for(i=1;i<=n;i++)\n    {\n        if(a[i]>255||b[i]>255||c[i]>255||d[i]>255||e[i]>65535||e[i]<=0||a[i]<0||b[i]<0||c[i]<0||d[i]<0)\n        {\n            cout<<\"ERR\"<<endl;\n            continue;\n        }\n        if(s1[i]==\"Server\")\n        {\n            if(i==1)\n            {\n                cout<<\"OK\"<<endl;\n                continue;\n            }\n            for(int j=1;j<=i-1;j++)\n            {\n                if(s1[j]==\"Server\"&&check(a[i],a[j],b[i],b[j],c[i],c[j],d[i],d[j],e[i],e[j])==false)\n                {\n                    cout<<\"OK\"<<endl;\n                    break;\n                }\n                else\n                {\n                    cout<<\"FAIL\"<<endl;\n                    break;\n                }\n            }\n        }\n        else\n        {\n            for(int j=1;j<=i-1;j++)\n            {\n                if(s1[j]==\"Server\"&&check(a[i],a[j],b[i],b[j],c[i],c[j],d[i],d[j],e[i],e[j])==true)\n                {\n                    cout<<j<<endl;\n                    flag=true;\n                    break;\n                }\n            }\n            if(flag==false)\n            {\n                cout<<\"FAIL\"<<endl;\n            }\n            flag=false;\n        }\n    }\n    return 0;\n}\n```\n\n### T4\n```cpp\n#include<iostream>\nusing namespace std;\nint main()\n{\n    freopen(\"fruit.in\",\"r\",stdin);\n    freopen(\"fruit.out\",\"w\",stdout);\n    cout<<\"完蛋了没时间了\"<<endl;\n    return 0;\n}\n```\n","tags":["考试游记"],"categories":["life"]},{"title":"洛谷P7745题解","url":"/2025/02/04/P7745/","content":"调了两个月终于调出来了。\n\n首先看数据范围： $1\\le n \\le 10^5$ 且 $1\\le m\\le 3\\times 10^5$\n\n纯根据题意模拟的 $O(n+mn)$ 肯定过不了\n\n这时候就需要预处理。\n\n### 对于曼哈顿距离，我们可以把它想象成一个点到另一个点的最短路，这边放个图例来方便理解\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/61zo4byi.png)\n\n如图，容易发现：\n\n图上 $x$ 轴距离和为 $1+1=2$，$y$ 轴距离和为$1+2=3$。\n\n$x$ , $y$ 轴距离和相加即为两个控制点到 ROBOT 的曼哈顿距离。\n\n一提到预处理，首先我们想到的是前缀和。\n\n求数组前缀和的方式十分简单，仅需要写一个循环，例如下方代码：\n\n```cpp\nfor(int i = 1; i < anumber; i++)\n    xa[i] = xa[i - 1] + xa[i]; //计算前缀和核心代码，下同\nfor(int i = 1; i < anumber; i++)\n    ya[i] = ya[i - 1] + ya[i];\n```\n\n在得到前缀和后，根据题意，容易得出每次移动对于每个控制点到ROBOT的距离 $+1$ 或 $-1$，我们只需要详细写出 $+1$ 或 $-1$ 即可。\n\n同样的，这边放一个 gif 来演示收到 \"J\" 指令是的操作情况。\n\n![](https://bu.dusays.com/2021/11/16/127e4f7aab5b5.gif)\n(如果 gif 挂了请@或私信我)\n\n举例当指令为 \"S\" 时：\n\n```cpp\nif(s[i] == 'S'){\n    tot += yn[y + zs]; //需要+1的数\n    tot -= (n - yn[y + zs]); //除去需要+1的，即为需要-1的\n    y++; //对应题目\n}\n```\n在一系列例如上方的处理后，我们仅需要提前(在输入每个机器人坐标时)算出初始距离，并对这个初始距离进行加减即可。\n\n写完后发现时间复杂度仅有 $O(n+m)$，可以轻松通过\n\n**当然，此题也可以用 STL 中的 lower_bound 和 upper_bound 写。**\n### 需要注意的是，为防止数组下标为负数，需要给每一个数组下标都加一个常量！\n\n\n","tags":["题解"],"categories":["OI"]},{"title":"CF245E题解","url":"/2025/02/04/CF245E/","content":"~~第一眼看还以为是DP呢。~~\n\n仔细一看，原来是道水题。\n\n## 题意\n\n给定一个带有 \"+\" 与 \"-\" 的字符串，表示这个叫做 \"Binary Cat\" 的咖啡厅的人进出情况。\n\n现在你是个保安，你要根据给你的字符串求出你见到了多少人。\n\n\"+\" 代表进入；\"-\" 代表出去。\n\n## 思路\n\n用两个变量来存在咖啡厅中与咖啡厅外的人，根据题意模拟：\n\n如果读到 \"+\" 则有一个**原本在咖啡厅外的人**进入了咖啡厅。\n\n反之，读到 \"-\" 则有一个**原本在咖啡厅内的人**出了咖啡厅。\n\n**特别地，我们需要注意，在一开始，咖啡厅内或外可能出现没人的情况，则是新来的人**\n\n\n## 代码实现\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nstring s;\nint main(){\n    cin.tie(0);\n    cout.tie(0);\n    int in = 0, out = 0, len = 0;\n    cin >> s;\n    len = s.length();\n    for(int i = 0; i < len; i++){\n        if(s[i] == '+'){\n            in++;\n            if(out) out--;//特判此时咖啡厅外已经有人\n        }\n        else if(s[i] == '-'){\n            out++;\n            if(in) in--; //特判此时咖啡内外已经有人\n        }\n    }\n    cout << in + out << endl;\n    return 0;\n}\n```\n","tags":["题解"],"categories":["OI"]},{"title":"SP10620题解","url":"/2025/02/04/SP10620/","content":"## 一道基础的贪心思想题目\n\n此题难点并不在代码构造，而在于思想。\n\n根据题意，已知：这 $ n $ 本书的编号为 $ 1 $ 到 $ n $，且无序。\n\n根据题目的排序方式，每一次将其中一本抽出并排到最**上面**(注意理解这个最上面，**此上面非彼上面**)。\n\n## 思路：\n\n倒着遍历数组，且把答案预设为 $n$，如果当前的元素与答案相等，那么则说明这个位置已经拍好，将 $ ans-1 $ 然后继续排序，反之当前元素应该拿到最上面去。\n\n这么做的时间复杂度为 $ O(n) $ ，可以轻松过。\n## AC  Code:\n\n```cpp\n#include <iostream>\nusing namespace std;\nint a[300005], n, ans;\nint main(){\n    cin >> n;\n    for(int i = 1; i <= n; i++){\n        cin>>a[i];\n    }\n    ans=n;//预设ans=n\n    for(int i = n; i >= 1; --i){ //注意是倒着遍历\n        if(ans == a[i]){\n            ans--;//贪心，推导如上\n        }\n    }\n    cout << ans << endl;//输出即可\n    return 0;\n}\n```\n\n\n","tags":["题解"],"categories":["OI"]},{"title":"洛谷P7757题解","url":"/2025/02/04/P7757/","content":"### 一道二分题\n\n#### 如果使用贪心，则会有时间复杂度 $O(m \\log_{} {n})$\n\n#### 因为数据范围 $m \\le 10^9$ 且 $n \\le 10^5$ 所以在最坏情况下会 TLE\n\n所以需要二分优化\n\n什么二分呢\n\n二分法分为二分查找与二分答案，二分查找注重于在一个集合（有序）里找到一个数，而二分答案注重于找到答案，简单来说，就是假设答案再判断对错，做调整\n\n不难写出二分模版\n\n```cpp\nwhile(l < r){\n    mid = (l + r) >> 1;\n    if(check(mid)) r = mid;\n    else l = mid + 1;\n}\n```\n\n这样一来 $O(x)$的复杂度就降到了$O( log\\ x)$\n\n我们只需要根据题意改改模版即可\n\n**此题思路：我们需要计算出每个服务台可办理的人数之和，然后判断是否大于，小于所给人数，进行二分法即可**\n\n\n### AC Code：\n\n```cpp\n#include <iostream>\nusing namespace std;\nlong long n, m, t[100005], ans, l = 1, r;\nint main(){\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++){\n        cin >> t[i];\n        if(t[i] >= r) r = t[i]; //找到集合t中的最大值\n    }\n    r *= m;//人数*服务台的最大时间，得最坏情况\n    long long cnt, mid;\n    while(l < r){//此处也可以用一个函数去写\n        mid = (l + r) >> 1, cnt = 0; //此处mid为l+r的一半\n        //并初始化cnt（用来计数人数之和）为0\n        //(x>>1)=(x/2)\n        for(int i = 1; i <= n; i++) cnt = cnt + mid / t[i]; //计算出每个服务台能办理的人数之和\n        if(cnt >= m) r = mid; //人数之和超过了总人数,使二分范围的最右边变成当前中间值\n        else l = mid + 1;//人数之和不到总人数,使二分范围的最左边变成当前中间值+1（中间值已经判断过）\n    }\n    //二分完的结果是l=r，即最终答案，因此输出l或者r都可以\n    cout << r << endl;\n    return 0;\n}\n```\n\n有哪里说的不对或者不是很好的请提出！谢谢各位！\n\n\n\n","tags":["题解"],"categories":["OI"]}]